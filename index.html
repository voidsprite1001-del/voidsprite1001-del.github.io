<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>星域长剑：零重力逃生</title>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js" type="module"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js" type="module"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js" type="module"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Orbitron:wght@400;700&display=swap');
        :root {
            --color-primary: #1e3a8a; /* Deep Blue */
            --color-secondary: #fcd34d; /* Amber */
            --color-danger: #dc2626;
            --color-text: #e0f2f1;
            --color-background: #0f172a; /* Dark Slate */
            --font-display: 'Orbitron', sans-serif;
            --font-body: 'Inter', sans-serif;
        }

        body {
            font-family: var(--font-body);
            background-color: var(--color-background);
            color: var(--color-text);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            width: 95%;
            max-width: 1000px;
            border-radius: 1rem;
            box-shadow: 0 0 40px rgba(30, 58, 138, 0.5);
            background-color: #1e293b;
            padding: 1rem;
        }

        canvas {
            background-color: #0b111e;
            border: 2px solid var(--color-primary);
            border-radius: 0.75rem;
            touch-action: none; /* Crucial for canvas touch interaction */
        }

        .ui-panel {
            font-family: var(--font-display);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            margin-bottom: 0.5rem;
        }

        .resource-bar {
            width: 150px;
            height: 12px;
            background-color: #475569;
            border-radius: 6px;
            overflow: hidden;
            margin-left: 0.5rem;
            margin-right: 1.5rem;
        }

        .resource-fill {
            height: 100%;
            transition: width 0.1s ease-out;
        }

        .health-bar .resource-fill { background-color: var(--color-danger); }
        .oxygen-bar .resource-fill { background-color: #0d9488; } /* Teal */
        .power-bar .resource-fill { background-color: var(--color-secondary); }

        .game-status {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            color: var(--color-text);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-family: var(--font-display);
            z-index: 100;
            border-radius: 0.75rem;
        }

        .game-status h1 {
            font-size: 2.5rem;
            color: var(--color-secondary);
            margin-bottom: 0.5rem;
        }

        .game-status p {
            font-size: 1.25rem;
            margin-bottom: 1.5rem;
        }

        .control-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            padding-top: 1rem;
        }

        .control-buttons button, .game-status button {
            font-family: var(--font-display);
            padding: 0.75rem 1.5rem;
            background: linear-gradient(145deg, var(--color-primary), #0c4a6e);
            color: var(--color-text);
            border: 2px solid var(--color-secondary);
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(30, 58, 138, 0.5);
            text-transform: uppercase;
        }

        .control-buttons button:hover, .game-status button:hover {
            background: linear-gradient(145deg, #0c4a6e, var(--color-primary));
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(252, 211, 77, 0.3);
        }

        /* Mobile Controls */
        #mobile-controls {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0;
        }

        @media (max-width: 768px) {
            .game-container {
                width: 100%;
                padding: 0.5rem;
                border-radius: 0;
            }
            .ui-panel {
                flex-wrap: wrap;
                justify-content: center;
            }
            .resource-display {
                margin-bottom: 0.5rem;
            }
            .desktop-controls {
                display: none;
            }
            #mobile-controls {
                display: flex;
            }
            #mobile-dpad {
                display: grid;
                grid-template-areas: ". up ." "left . right" ". down .";
                gap: 0.25rem;
                margin-bottom: 0.5rem;
            }
            .mobile-button {
                width: 60px;
                height: 60px;
                display: flex;
                justify-content: center;
                align-items: center;
                background-color: var(--color-primary);
                border: 1px solid var(--color-secondary);
                border-radius: 0.5rem;
                font-size: 1rem;
                touch-action: manipulation;
                user-select: none;
            }
            #thrust-up { grid-area: up; }
            #thrust-left { grid-area: left; }
            #thrust-right { grid-area: right; }
            #thrust-down { grid-area: down; }

            #mobile-action-buttons {
                display: flex;
                gap: 1rem;
            }
        }
    </style>
</head>
<body>

<div class="game-container">
    <!-- UI Panel -->
    <div class="ui-panel">
        <div class="flex items-center text-sm">
            时间: <span id="time-display" class="ml-1 text-lg text-white">00:00</span>
        </div>
        <div class="flex flex-col sm:flex-row items-center">
            <div class="flex items-center text-xs resource-display">
                生命
                <div class="resource-bar health-bar">
                    <div id="health-fill" class="resource-fill" style="width: 100%;"></div>
                </div>
            </div>
            <div class="flex items-center text-xs resource-display">
                氧气
                <div class="resource-bar oxygen-bar">
                    <div id="oxygen-fill" class="resource-fill" style="width: 100%;"></div>
                </div>
            </div>
            <div class="flex items-center text-xs resource-display">
                电力
                <div class="resource-bar power-bar">
                    <div id="power-fill" class="resource-fill" style="width: 100%;"></div>
                </div>
            </div>
        </div>
        <div class="flex items-center text-sm">
            UID: <span id="user-id-display" class="ml-1 text-xs text-yellow-300">Loading...</span>
        </div>
    </div>

    <!-- Canvas -->
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <!-- Game Status Overlay -->
    <div id="game-status-overlay" class="game-status absolute inset-0 hidden">
        <div class="p-8 bg-gray-800/90 rounded-xl shadow-2xl border-4 border-yellow-500">
            <h1 id="status-title">星域长剑：零重力逃生</h1>
            <p id="status-message">WASD/方向键 推进器 | 鼠标点击/触摸 虚空之刃牵引 | R 虹吸能量 | P/Space 斩击</p>
            <p class="text-xs text-gray-400 mt-4">当前用户ID (分享此ID): <span id="user-id-overlay">...</span></p>
            <p id="high-score-display" class="text-sm mt-2 text-green-300">本地最佳时间: N/A | 全局最佳时间: N/A</p>
            <button id="start-button">开始逃生</button>
        </div>
    </div>

    <!-- Desktop Controls Hint -->
    <div class="control-buttons desktop-controls">
        <span class="text-sm text-gray-400">WASD/方向键: 推进 | 鼠标左键: 牵引 | R: 虹吸 | P/Space: 斩击</span>
    </div>

    <!-- Mobile Controls -->
    <div id="mobile-controls">
        <div id="mobile-dpad" class="flex-row">
            <button id="thrust-up" class="mobile-button">↑</button>
            <button id="thrust-left" class="mobile-button">←</button>
            <button id="thrust-right" class="mobile-button">→</button>
            <button id="thrust-down" class="mobile-button">↓</button>
        </div>
        <div id="mobile-action-buttons">
            <button id="action-grapple" class="mobile-button">牵引 (Tether)</button>
            <button id="action-siphon" class="mobile-button">虹吸 (Siphon)</button>
            <button id="action-slash" class="mobile-button">斩击 (Slash)</button>
        </div>
    </div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, query, limit, where, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- Firebase Setup and Constants (MANDATORY GLOBALS) ---
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
    
    let db, auth;
    let userId = 'loading';
    let isAuthReady = false;
    let globalBestTime = 'N/A';
    let userBestTime = 'N/A';

    // Set Firebase Debug Log Level
    setLogLevel('Debug');

    if (firebaseConfig) {
        const app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        auth = getAuth(app);

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
            } else {
                // If auth token is not provided (e.g., in a local development environment), sign in anonymously.
                try {
                    await signInAnonymously(auth);
                    userId = auth.currentUser.uid;
                } catch (error) {
                    console.error("Anonymous sign in failed:", error);
                    userId = 'unauthenticated-' + crypto.randomUUID();
                }
            }
            document.getElementById('user-id-display').textContent = userId.substring(0, 8) + '...';
            document.getElementById('user-id-overlay').textContent = userId;
            isAuthReady = true;
            console.log("Firebase Auth Ready. User ID:", userId);

            // Start listening for scores once auth is ready
            listenForScores();
        });

        // Use custom token if provided (Canvas environment)
        if (initialAuthToken) {
            signInWithCustomToken(auth, initialAuthToken).catch(error => {
                console.error("Custom token sign in failed:", error);
            });
        }
    } else {
        // Fallback for no Firebase config
        userId = 'no-firebase-' + crypto.randomUUID();
        document.getElementById('user-id-display').textContent = userId.substring(0, 8) + '...';
        document.getElementById('user-id-overlay').textContent = userId;
        isAuthReady = true;
        console.warn("Firebase config not found. Running without persistent storage.");
    }

    /**
     * Firestore: Saves the user's best time.
     * @param {number} time The escape time in milliseconds.
     */
    async function saveBestTime(time) {
        if (!isAuthReady || !db) {
            console.warn("Firebase not ready or not configured. Cannot save score.");
            return;
        }
        
        const scoreCollectionRef = collection(db, 'artifacts', appId, 'public', 'data', 'zero_g_escape_scores');
        const userDocRef = doc(scoreCollectionRef, userId);
        const newTimeInSeconds = (time / 1000).toFixed(2);

        try {
            const docSnap = await getDoc(userDocRef);

            let shouldUpdate = false;
            if (docSnap.exists()) {
                const data = docSnap.data();
                if (newTimeInSeconds < data.bestTimeSeconds || data.bestTimeSeconds === 0) {
                    shouldUpdate = true;
                }
            } else {
                shouldUpdate = true; // First time saving
            }

            if (shouldUpdate) {
                await setDoc(userDocRef, {
                    userId: userId,
                    bestTimeSeconds: newTimeInSeconds,
                    timestamp: Date.now(),
                }, { merge: true });
                console.log("New best time saved:", newTimeInSeconds);
            }
        } catch (e) {
            console.error("Error saving score:", e);
        }
    }

    /**
     * Firestore: Listens for the global best time and the user's best time.
     */
    function listenForScores() {
        if (!isAuthReady || !db) return;

        const scoreCollectionRef = collection(db, 'artifacts', appId, 'public', 'data', 'zero_g_escape_scores');
        
        // 1. Listen for user's best score
        const userDocRef = doc(scoreCollectionRef, userId);
        onSnapshot(userDocRef, (docSnap) => {
            if (docSnap.exists()) {
                userBestTime = parseFloat(docSnap.data().bestTimeSeconds).toFixed(2) + 's';
            } else {
                userBestTime = 'N/A';
            }
            updateHighScoreDisplay();
        });

        // 2. Listen for global best score (simplified: querying the lowest time)
        // Note: For a true global leader, we would ideally use an aggregated query or a separate leader document,
        // but for simplicity and index avoidance, we will query the collection and sort client-side.
        onSnapshot(scoreCollectionRef, (snapshot) => {
            let scores = [];
            snapshot.forEach(doc => {
                const data = doc.data();
                scores.push({ time: parseFloat(data.bestTimeSeconds), userId: data.userId });
            });

            if (scores.length > 0) {
                scores.sort((a, b) => a.time - b.time);
                globalBestTime = scores[0].time.toFixed(2) + 's' + (scores[0].userId === userId ? ' (You)' : '');
            } else {
                globalBestTime = 'N/A';
            }
            updateHighScoreDisplay();
        });
    }

    function formatTime(ms) {
        const totalSeconds = Math.floor(ms / 1000);
        const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, '0');
        const seconds = String(totalSeconds % 60).padStart(2, '0');
        const milliseconds = String(Math.floor((ms % 1000) / 10)).padStart(2, '0');
        return `${minutes}:${seconds}.${milliseconds}`;
    }

    function updateHighScoreDisplay() {
        const display = document.getElementById('high-score-display');
        display.innerHTML = `本地最佳时间 (User): <span class="text-white">${userBestTime}</span> | 全局最佳时间: <span class="text-white">${globalBestTime}</span>`;
    }

    // --- Game Engine Core ---

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const GAME_WIDTH = 800;
    const GAME_HEIGHT = 600;
    canvas.width = GAME_WIDTH;
    canvas.height = GAME_HEIGHT;

    // JS Color Constants derived from CSS variables for Canvas rendering
    const COLOR_PRIMARY = '#1e3a8a';
    const COLOR_SECONDARY = '#fcd34d';
    const COLOR_DANGER = '#dc2626';
    const COLOR_TEXT = '#e0f2f1';
    const COLOR_TEAL = '#0d9488';
    const COLOR_DARK_GREY = '#374151';
    const COLOR_BG = '#152135';

    // Responsive Canvas Resizing
    function resizeCanvas() {
        const container = canvas.parentElement;
        const ratio = GAME_WIDTH / GAME_HEIGHT;
        let newWidth = container.clientWidth;
        let newHeight = newWidth / ratio;

        if (newHeight > (window.innerHeight - 150)) {
            newHeight = window.innerHeight - 150;
            newWidth = newHeight * ratio;
        }

        canvas.style.width = `${newWidth}px`;
        canvas.style.height = `${newHeight}px`;
    }

    window.addEventListener('resize', resizeCanvas);
    window.onload = () => {
        resizeCanvas();
        animate(0); // Start the game loop on load
    };

    // Game Constants
    const ZERO_G_DRAG = 0.998; // Very low drag for zero-G feel
    const MAX_VELOCITY = 10;
    const THRUST_FORCE = 0.05;
    const OXYGEN_DRAIN_RATE = 0.005; // per frame
    const POWER_DRAIN_THRUST = 0.08;
    const POWER_DRAIN_TETHER = 0.15;
    const POWER_DRAIN_SLASH = 5;
    const POWER_SIPHON_GAIN = 100;
    const HEALTH_RECOVERY_RATE = 0.01;
    const SIPHON_COOLDOWN_FRAMES = 600; // 10 seconds at 60 FPS

    // Game State
    let gameState = {
        running: false,
        startTime: 0,
        elapsedTime: 0,
        lastFrameTime: 0,
        siphonCooldown: 0,
        isGrappling: false,
        grappleTarget: { x: 0, y: 0 },
        isSlashing: false,
        slashFrameCount: 0,
    };

    // Player Object (Kael)
    let player = {
        x: 50,
        y: GAME_HEIGHT / 2,
        radius: 10,
        velX: 0,
        velY: 0,
        health: 100,
        oxygen: 100,
        power: 100,
    };

    // Environment/Colliders
    let walls = [
        // Outer walls
        { x: 0, y: 0, w: GAME_WIDTH, h: 10, type: 'wall' },
        { x: 0, y: GAME_HEIGHT - 10, w: GAME_WIDTH, h: 10, type: 'wall' },
        { x: 0, y: 0, w: 10, h: GAME_HEIGHT, type: 'wall' },
        // Goal/Escape Hatch (Top right)
        { x: GAME_WIDTH - 20, y: 0, w: 20, h: 50, type: 'goal' },
        // Obstacles (Narrow passage example)
        { x: 200, y: 100, w: 20, h: 300, type: 'wall' },
        { x: 400, y: 200, w: 200, h: 20, type: 'wall' },
    ];

    // Hazards (e.g., Radiation/Heat)
    let hazards = [
        { x: 300, y: 0, w: 50, h: 150, type: 'radiation', damage: 0.1 },
        { x: 500, y: 400, w: 100, h: 100, type: 'heat', damage: 0.05 },
    ];

    // Resources (Oxygen/Power Stations)
    let resources = [
        { x: 100, y: 100, radius: 15, type: 'oxygen', amount: 50 },
        { x: 600, y: 500, radius: 15, type: 'power', amount: 50 },
        // Siphon point (for emergency power)
        { x: 300, y: 300, radius: 10, type: 'siphon_point', isSiphoning: false, range: 50 },
    ];

    // Enemies (Maint-Drones)
    let enemies = [
        createEnemy(400, 100),
        createEnemy(500, 300),
        createEnemy(700, 400),
    ];

    function createEnemy(x, y) {
        return {
            x: x, y: y, radius: 8, velX: (Math.random() - 0.5) * 0.5, velY: (Math.random() - 0.5) * 0.5,
            health: 20, maxHealth: 20, type: 'Maint-Drone', color: '#8b5cf6'
        };
    }

    // Input Handling
    let keys = {};
    let touchStartPos = { x: 0, y: 0 };

    document.addEventListener('keydown', (e) => {
        keys[e.key] = true;
        if (e.key === 'R' || e.key === 'r') {
            siphonPower();
        }
        if (e.key === ' ' || e.key === 'p' || e.key === 'P') {
            slashAttack();
        }
    });
    document.addEventListener('keyup', (e) => {
        keys[e.key] = false;
    });

    // Mouse/Touch Grapple (Primary Zero-G Movement)
    canvas.addEventListener('mousedown', (e) => {
        if (!gameState.running) return;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        gameState.isGrappling = true;
        gameState.grappleTarget.x = (e.clientX - rect.left) * scaleX;
        gameState.grappleTarget.y = (e.clientY - rect.top) * scaleY;
    });

    canvas.addEventListener('mouseup', () => {
        gameState.isGrappling = false;
    });

    // Touch Event Handling (Grapple/Slash)
    canvas.addEventListener('touchstart', (e) => {
        if (!gameState.running) return;
        e.preventDefault();
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        // Store initial touch position for potential swipe/drag detection
        touchStartPos.x = touch.clientX;
        touchStartPos.y = touch.clientY;

        // Immediately start grappling towards the touch point
        gameState.isGrappling = true;
        gameState.grappleTarget.x = (touch.clientX - rect.left) * scaleX;
        gameState.grappleTarget.y = (touch.clientY - rect.top) * scaleY;
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
        gameState.isGrappling = false;
        // Simple tap detection for slash attack (if touch position didn't move much)
        const touch = e.changedTouches[0];
        if (Math.abs(touch.clientX - touchStartPos.x) < 10 && Math.abs(touch.clientY - touchStartPos.y) < 10) {
            slashAttack();
        }
    });

    // Mobile Thrust Control (Hold to thrust)
    function setupMobileControls() {
        const buttons = [
            { id: 'thrust-up', keys: ['ArrowUp', 'w'], event: 'touchstart' },
            { id: 'thrust-down', keys: ['ArrowDown', 's'], event: 'touchstart' },
            { id: 'thrust-left', keys: ['ArrowLeft', 'a'], event: 'touchstart' },
            { id: 'thrust-right', keys: ['ArrowRight', 'd'], event: 'touchstart' },
        ];

        buttons.forEach(({ id, keys, event }) => {
            const btn = document.getElementById(id);
            if (btn) {
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    keys.forEach(key => keys[key] = true);
                });
                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    keys.forEach(key => keys[key] = false);
                });
            }
        });

        // Action buttons
        document.getElementById('action-siphon')?.addEventListener('click', siphonPower);
        document.getElementById('action-slash')?.addEventListener('click', slashAttack);
        // Note: Grapple action is handled directly on canvas touch events
    }
    setupMobileControls();


    function startGame() {
        player.x = 50;
        player.y = GAME_HEIGHT / 2;
        player.velX = 0;
        player.velY = 0;
        player.health = 100;
        player.oxygen = 100;
        player.power = 100;

        enemies = [
            createEnemy(400, 100),
            createEnemy(500, 300),
            createEnemy(700, 400),
        ];

        gameState.running = true;
        gameState.startTime = Date.now();
        gameState.siphonCooldown = 0;
        document.getElementById('game-status-overlay').classList.add('hidden');
    }

    function gameOver(win = false) {
        gameState.running = false;
        const overlay = document.getElementById('game-status-overlay');
        const title = document.getElementById('status-title');
        const message = document.getElementById('status-message');
        const button = document.getElementById('start-button');
        
        if (win) {
            const finalTime = gameState.elapsedTime;
            title.textContent = "逃生成功！ (Escape Successful!)";
            message.textContent = `您在 ${formatTime(finalTime)} 内抵达方舟。这是星域长剑的胜利！`;
            button.textContent = "再次尝试 (Play Again)";
            saveBestTime(finalTime);
        } else {
            title.textContent = "逃生失败 (Escape Failed)";
            message.textContent = player.health <= 0 ? "生命耗尽，系统关闭。" : "氧气耗尽，虚空长眠。";
            button.textContent = "重新开始 (Restart)";
        }

        // Ensure current scores are up to date before showing overlay
        updateHighScoreDisplay();
        overlay.classList.remove('hidden');
    }

    // --- Core Mechanisms (The Void-Blade) ---

    function siphonPower() {
        if (!gameState.running || gameState.siphonCooldown > 0) return;

        // Check proximity to a siphon point
        const siphonPoint = resources.find(r => r.type === 'siphon_point');
        if (siphonPoint) {
            const dx = siphonPoint.x - player.x;
            const dy = siphonPoint.y - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < siphonPoint.range + player.radius) {
                player.power = Math.min(100, player.power + POWER_SIPHON_GAIN);
                gameState.siphonCooldown = SIPHON_COOLDOWN_FRAMES;
                console.log("Power Siphoned! Cooldown started.");
            } else {
                console.log("Too far from a Siphon Point.");
            }
        }
    }

    function slashAttack() {
        if (!gameState.running || player.power < POWER_DRAIN_SLASH || gameState.isSlashing) return;
        
        player.power = Math.max(0, player.power - POWER_DRAIN_SLASH);
        gameState.isSlashing = true;
        gameState.slashFrameCount = 0;
    }

    function updateSlash() {
        if (!gameState.isSlashing) return;

        gameState.slashFrameCount++;
        const slashDuration = 10; // frames

        if (gameState.slashFrameCount > slashDuration) {
            gameState.isSlashing = false;
            return;
        }

        // Determine player's forward direction based on current velocity
        let dirX = player.velX || 1;
        let dirY = player.velY || 0;
        const magnitude = Math.sqrt(dirX * dirX + dirY * dirY) || 1;
        dirX /= magnitude;
        dirY /= magnitude;

        const slashRange = 40;
        const slashRadius = 20;

        // Check for enemy hit
        enemies.forEach(enemy => {
            const dx = enemy.x - (player.x + dirX * slashRange / 2);
            const dy = enemy.y - (player.y + dirY * slashRange / 2);
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < enemy.radius + slashRadius) {
                // Apply damage
                enemy.health -= 10;
                // Apply force/momentum transfer to enemy AND player
                const momentumForce = 5;
                enemy.velX += dirX * momentumForce;
                enemy.velY += dirY * momentumForce;

                // Player is pushed back due to zero-G conservation of momentum
                player.velX -= dirX * momentumForce * 0.2; // Smaller push back
                player.velY -= dirY * momentumForce * 0.2;
            }
        });
    }

    // --- Physics and Update Logic ---

    function updatePlayer() {
        // 1. Thrust Input
        const inputX = (keys['ArrowRight'] || keys['d'] ? 1 : 0) - (keys['ArrowLeft'] || keys['a'] ? 1 : 0);
        const inputY = (keys['ArrowDown'] || keys['s'] ? 1 : 0) - (keys['ArrowUp'] || keys['w'] ? 1 : 0);
        
        if ((inputX !== 0 || inputY !== 0) && player.power > 0) {
            player.velX += inputX * THRUST_FORCE;
            player.velY += inputY * THRUST_FORCE;
            player.power = Math.max(0, player.power - POWER_DRAIN_THRUST);
        }

        // 2. Grapple/Tether
        if (gameState.isGrappling && player.power > 0) {
            const dx = gameState.grappleTarget.x - player.x;
            const dy = gameState.grappleTarget.y - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > player.radius) {
                const angle = Math.atan2(dy, dx);
                const tetherForce = 0.5;
                player.velX += Math.cos(angle) * tetherForce;
                player.velY += Math.sin(angle) * tetherForce;
                player.power = Math.max(0, player.power - POWER_DRAIN_TETHER);
            } else {
                gameState.isGrappling = false;
            }
        } else {
            gameState.isGrappling = false; // Stop grappling if power runs out
        }

        // 3. Apply Zero-G Drag
        player.velX *= ZERO_G_DRAG;
        player.velY *= ZERO_G_DRAG;

        // 4. Limit Velocity
        const speed = Math.sqrt(player.velX * player.velX + player.velY * player.velY);
        if (speed > MAX_VELOCITY) {
            const ratio = MAX_VELOCITY / speed;
            player.velX *= ratio;
            player.velY *= ratio;
        }

        // 5. Apply Position Update
        player.x += player.velX;
        player.y += player.velY;

        // 6. Resource Management
        player.oxygen = Math.max(0, player.oxygen - OXYGEN_DRAIN_RATE);
        player.health = Math.min(100, player.health + HEALTH_RECOVERY_RATE); // Minor passive recovery
    }

    function checkCollisions() {
        // Wall/Obstacle Collisions
        walls.forEach(wall => {
            // Simple AABB vs Circle collision check (Simplified bounce)
            // Get the closest point on the AABB to the circle
            const closestX = Math.max(wall.x, Math.min(player.x, wall.x + wall.w));
            const closestY = Math.max(wall.y, Math.min(player.y, wall.y + wall.h));

            const dx = player.x - closestX;
            const dy = player.y - closestY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < player.radius) {
                if (wall.type === 'goal') {
                    gameOver(true);
                    return;
                }

                // Collision detected. Push player out.
                const overlap = player.radius - distance;
                const pushX = dx / distance * overlap;
                const pushY = dy / distance * overlap;

                player.x += pushX;
                player.y += pushY;

                // Reflect velocity (bounce)
                const bounceFactor = 0.8;
                if (Math.abs(closestX - player.x) > Math.abs(closestY - player.y)) {
                    player.velX *= -bounceFactor;
                } else {
                    player.velY *= -bounceFactor;
                }

                // Small impact damage based on speed
                player.health = Math.max(0, player.health - Math.min(10, Math.sqrt(player.velX * player.velX + player.velY * player.velY) * 2));
            }
        });

        // Hazard Collisions
        hazards.forEach(hazard => {
            const closestX = Math.max(hazard.x, Math.min(player.x, hazard.x + hazard.w));
            const closestY = Math.max(hazard.y, Math.min(player.y, hazard.y + hazard.h));

            const dx = player.x - closestX;
            const dy = player.y - closestY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < player.radius) {
                player.health = Math.max(0, player.health - hazard.damage);
            }
        });

        // Resource Collection
        resources = resources.filter(resource => {
            if (resource.type === 'siphon_point') return true; // Siphon points are permanent

            const dx = resource.x - player.x;
            const dy = resource.y - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < player.radius + resource.radius) {
                if (resource.type === 'oxygen') {
                    player.oxygen = Math.min(100, player.oxygen + resource.amount);
                } else if (resource.type === 'power') {
                    player.power = Math.min(100, player.power + resource.amount);
                }
                // Resource consumed
                return false;
            }
            return true;
        });

        // Enemy-Player Collisions
        enemies.forEach(enemy => {
            const dx = enemy.x - player.x;
            const dy = enemy.y - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < player.radius + enemy.radius) {
                // Collision: Apply damage and recoil
                player.health = Math.max(0, player.health - 5);
                
                // Push objects apart (recoil/bounce)
                const overlap = player.radius + enemy.radius - dist;
                const angle = Math.atan2(dy, dx);
                const totalMass = player.radius + enemy.radius;
                const playerMassRatio = enemy.radius / totalMass;
                const enemyMassRatio = player.radius / totalMass;

                player.x -= Math.cos(angle) * overlap * playerMassRatio;
                player.y -= Math.sin(angle) * overlap * playerMassRatio;
                enemy.x += Math.cos(angle) * overlap * enemyMassRatio;
                enemy.y += Math.sin(angle) * overlap * enemyMassRatio;

                // Simple velocity exchange
                player.velX -= Math.cos(angle) * 1.5;
                player.velY -= Math.sin(angle) * 1.5;
                enemy.velX += Math.cos(angle) * 1.5;
                enemy.velY += Math.sin(angle) * 1.5;
            }
        });
    }

    function updateEnemies() {
        enemies = enemies.filter(enemy => enemy.health > 0);

        enemies.forEach(enemy => {
            // Apply Zero-G Drag
            enemy.velX *= ZERO_G_DRAG;
            enemy.velY *= ZERO_G_DRAG;

            // Simple movement (Drones slowly track the player)
            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > 100) {
                 const angle = Math.atan2(dy, dx);
                 enemy.velX += Math.cos(angle) * 0.01;
                 enemy.velY += Math.sin(angle) * 0.01;
            }

            // Apply Position Update
            enemy.x += enemy.velX;
            enemy.y += enemy.velY;

            // Simple boundary bounce for enemies (so they don't drift away)
            if (enemy.x - enemy.radius < 0 || enemy.x + enemy.radius > GAME_WIDTH) {
                enemy.velX *= -1;
                enemy.x = Math.min(GAME_WIDTH - enemy.radius, Math.max(enemy.radius, enemy.x));
            }
            if (enemy.y - enemy.radius < 0 || enemy.y + enemy.radius > GAME_HEIGHT) {
                enemy.velY *= -1;
                enemy.y = Math.min(GAME_HEIGHT - enemy.radius, Math.max(enemy.radius, enemy.y));
            }
        });
    }


    // --- Drawing Functions ---

    function drawPlayer() {
        // Player Body
        ctx.fillStyle = player.health > 25 ? COLOR_TEXT : COLOR_DANGER;
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
        ctx.fill();

        // Direction indicator (simple nose)
        const angle = Math.atan2(player.velY, player.velX) || -Math.PI / 2;
        ctx.fillStyle = COLOR_SECONDARY;
        ctx.beginPath();
        ctx.arc(player.x + Math.cos(angle) * player.radius, player.y + Math.sin(angle) * player.radius, 3, 0, Math.PI * 2);
        ctx.fill();
    }

    function drawGrapple() {
        if (gameState.isGrappling) {
            ctx.strokeStyle = COLOR_SECONDARY; // Amber tether beam
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(player.x, player.y);
            ctx.lineTo(gameState.grappleTarget.x, gameState.grappleTarget.y);
            ctx.stroke();

            // Draw target anchor
            ctx.fillStyle = COLOR_SECONDARY;
            ctx.beginPath();
            ctx.arc(gameState.grappleTarget.x, gameState.grappleTarget.y, 4, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    function drawSlash() {
        if (!gameState.isSlashing) return;

        const slashPower = 1 - (gameState.slashFrameCount / 10); // Fades out
        ctx.strokeStyle = `rgba(255, 255, 255, ${slashPower})`;
        ctx.lineWidth = 3;

        // Determine slash direction (simplified: straight ahead of velocity)
        let dirX = player.velX || 1;
        let dirY = player.velY || 0;
        const magnitude = Math.sqrt(dirX * dirX + dirY * dirY) || 1;
        dirX /= magnitude;
        dirY /= magnitude;

        const slashLength = 40;
        const startX = player.x + dirX * player.radius * 0.5;
        const startY = player.y + dirY * player.radius * 0.5;
        const endX = startX + dirX * slashLength;
        const endY = startY + dirY * slashLength;

        // Draw the blade line
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
    }

    function drawEnvironment() {
        walls.forEach(wall => {
            if (wall.type === 'goal') {
                ctx.fillStyle = '#10b981'; // Emerald Green for Escape Hatch
            } else {
                ctx.fillStyle = COLOR_DARK_GREY; // Dark Grey Wall
            }
            ctx.fillRect(wall.x, wall.y, wall.w, wall.h);
        });

        hazards.forEach(hazard => {
            if (hazard.type === 'radiation') {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.1)'; // Red glow
            } else if (hazard.type === 'heat') {
                ctx.fillStyle = 'rgba(255, 165, 0, 0.1)'; // Orange glow
            }
            ctx.fillRect(hazard.x, hazard.y, hazard.w, hazard.h);

            // Draw boundary lines
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
            ctx.strokeRect(hazard.x, hazard.y, hazard.w, hazard.h);
        });

        resources.forEach(resource => {
            if (resource.type === 'oxygen') {
                ctx.fillStyle = COLOR_TEAL;
            } else if (resource.type === 'power') {
                ctx.fillStyle = COLOR_SECONDARY;
            } else if (resource.type === 'siphon_point') {
                ctx.fillStyle = gameState.siphonCooldown > 0 ? '#4b5563' : COLOR_PRIMARY;
            }

            ctx.beginPath();
            ctx.arc(resource.x, resource.y, resource.radius, 0, Math.PI * 2);
            ctx.fill();

            if (resource.type === 'siphon_point' && gameState.siphonCooldown > 0) {
                // Draw cooldown arc
                const startAngle = -Math.PI / 2;
                const endAngle = startAngle + (Math.PI * 2) * (gameState.siphonCooldown / SIPHON_COOLDOWN_FRAMES);
                ctx.strokeStyle = COLOR_SECONDARY;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(resource.x, resource.y, resource.radius + 5, startAngle, endAngle, false);
                ctx.stroke();
            }
        });

        enemies.forEach(enemy => {
            ctx.fillStyle = enemy.color;
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
            ctx.fill();

            // Draw health bar above enemy
            const barWidth = 20;
            const barHeight = 3;
            ctx.fillStyle = '#475569';
            ctx.fillRect(enemy.x - barWidth / 2, enemy.y - enemy.radius - barHeight - 2, barWidth, barHeight);
            ctx.fillStyle = '#dc2626';
            ctx.fillRect(enemy.x - barWidth / 2, enemy.y - enemy.radius - barHeight - 2, barWidth * (enemy.health / enemy.maxHealth), barHeight);
        });
    }

    function updateUI() {
        document.getElementById('health-fill').style.width = `${player.health.toFixed(0)}%`;
        document.getElementById('oxygen-fill').style.width = `${player.oxygen.toFixed(0)}%`;
        document.getElementById('power-fill').style.width = `${player.power.toFixed(0)}%`;

        if (gameState.running) {
            gameState.elapsedTime = Date.now() - gameState.startTime;
            document.getElementById('time-display').textContent = formatTime(gameState.elapsedTime);
        }
    }

    // --- Main Game Loop ---

    function animate(timestamp) {
        requestAnimationFrame(animate);

        // Calculate Delta Time (useful for framerate independence, though simplified here)
        // const deltaTime = timestamp - gameState.lastFrameTime;
        // gameState.lastFrameTime = timestamp;

        if (!gameState.running) {
            if (isAuthReady) updateHighScoreDisplay();
            return;
        }

        // 1. Update Cooldowns and UI
        gameState.siphonCooldown = Math.max(0, gameState.siphonCooldown - 1);
        updateUI();

        // 2. Physics & Logic Updates
        updatePlayer();
        updateEnemies();
        checkCollisions();
        updateSlash();

        // 3. Game Over Checks
        if (player.health <= 0 || player.oxygen <= 0) {
            gameOver(false);
        }

        // 4. Drawing
        ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        
        // Draw Grid/Atmosphere (Subtle Background)
        ctx.fillStyle = COLOR_BG;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        drawEnvironment();
        drawGrapple();
        drawSlash();
        drawPlayer();
    }

    // Event Listeners for Start/Restart
    document.getElementById('start-button').addEventListener('click', startGame);

    // Initial check to show the start screen
    document.getElementById('game-status-overlay').classList.remove('hidden');

</script>
</body>
</html>
