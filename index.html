<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>星域长剑：零重力逃生 (升级版)</title>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js" type="module"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js" type="module"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js" type="module"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Orbitron:wght@400;700&display=swap');
        :root {
            --color-primary: #1e3a8a; /* Deep Blue */
            --color-secondary: #fcd34d; /* Amber */
            --color-danger: #dc2626;
            --color-text: #e0f2f1;
            --color-background: #0f172a; /* Dark Slate */
            --font-display: 'Orbitron', sans-serif;
            --font-body: 'Inter', sans-serif;
        }

        body {
            font-family: var(--font-body);
            background-color: var(--color-background);
            color: var(--color-text);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            width: 95%;
            max-width: 1000px;
            border-radius: 1rem;
            box-shadow: 0 0 40px rgba(30, 58, 138, 0.5);
            background-color: #1e293b;
            padding: 1rem;
        }

        canvas {
            background-color: #0b111e;
            border: 2px solid var(--color-primary);
            border-radius: 0.75rem;
            touch-action: none; 
        }

        .ui-panel {
            font-family: var(--font-display);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            margin-bottom: 0.5rem;
        }
        
        .resource-bar {
            width: 100px; 
            height: 10px;
            background-color: #475569;
            border-radius: 5px;
            overflow: hidden;
            margin-left: 0.25rem;
            margin-right: 0.75rem;
        }

        .resource-fill {
            height: 100%;
            transition: width 0.1s ease-out;
        }

        .health-bar .resource-fill { background-color: var(--color-danger); }
        .oxygen-bar .resource-fill { background-color: #0d9488; } 
        .energy-bar .resource-fill { background-color: var(--color-secondary); } 

        .game-status, .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            color: var(--color-text);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-family: var(--font-display);
            z-index: 100;
            border-radius: 0.75rem;
        }
        
        .modal-content {
            background-color: #1e293b;
            border: 3px solid var(--color-primary);
            border-radius: 1rem;
            padding: 2rem;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 0 30px rgba(252, 211, 77, 0.2);
            position: relative;
        }

        .game-status h1, .modal h2 {
            font-size: 2.25rem;
            color: var(--color-secondary);
            margin-bottom: 0.75rem;
        }

        .status-options, .skill-node {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin-top: 1rem;
        }

        .control-buttons button, .game-status button, .modal button, .ui-panel button {
            font-family: var(--font-display);
            padding: 0.75rem 1.5rem;
            background: linear-gradient(145deg, var(--color-primary), #0c4a6e);
            color: var(--color-text);
            border: 2px solid var(--color-secondary);
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(30, 58, 138, 0.5);
            text-transform: uppercase;
        }
        
        .control-buttons button:hover, .game-status button:hover, .modal button:hover, .ui-panel button:hover {
            background: linear-gradient(145deg, #0c4a6e, var(--color-primary));
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(252, 211, 77, 0.3);
        }

        .skill-node {
            background-color: #0f172a;
            border: 1px solid var(--color-primary);
            padding: 1rem;
            border-radius: 0.5rem;
            text-align: left;
        }
        .skill-node h3 {
            color: var(--color-secondary);
            font-size: 1.125rem;
            margin-bottom: 0.25rem;
        }
        .skill-node p {
            font-size: 0.875rem;
            color: #94a3b8;
        }
        .skill-node .level-info {
            font-weight: bold;
            color: var(--color-text);
            margin-top: 0.5rem;
        }
        .upgrade-button:disabled {
            background: #475569;
            border-color: #64748b;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        
        #event-display {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--color-danger);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 0 15px rgba(220, 38, 38, 0.7);
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
            pointer-events: none;
            font-family: var(--font-display);
            z-index: 101;
        }
        
        .event-active {
            opacity: 1 !important;
            transform: translate(-50%, 0) !important;
        }

        .ui-panel .action-button {
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
            min-width: 80px;
        }

        @media (max-width: 768px) {
            .game-container {
                width: 100%;
                padding: 0.5rem;
                border-radius: 0;
            }
            .ui-panel {
                flex-wrap: wrap;
                justify-content: space-around;
            }
            .resource-display {
                margin-bottom: 0.5rem;
            }
            .desktop-controls {
                display: none;
            }
            #mobile-controls {
                display: flex;
            }
            /* Adjust UI panel alignment for mobile */
            .ui-panel > div:nth-child(1) { order: 1; width: 100%; text-align: center; } /* Time/ID */
            .ui-panel > div:nth-child(2) { order: 3; flex-grow: 1; justify-content: space-around; } /* Resources */
            .ui-panel > div:nth-child(3) { order: 2; display: flex; align-items: center; justify-content: space-between; width: 100%; margin-top: 0.5rem; } /* SP/Buttons */
            
            .skill-tree-button, #reset-game-button {
                padding: 0.3rem 0.6rem;
                font-size: 0.7rem;
            }
        }
    </style>
</head>
<body>

<div class="game-container">
    <!-- UI Panel -->
    <div class="ui-panel">
        <div class="flex flex-col sm:flex-row items-center text-sm">
            <span class="text-xs text-gray-400 mr-2 whitespace-nowrap overflow-hidden text-ellipsis max-w-[150px] sm:max-w-none">ID: <span id="user-id-display" class="text-white text-xs">加载中...</span></span> 
            时间: <span id="time-display" class="ml-1 text-lg text-white">00:00.00</span>
            <span class="ml-4 text-xs text-gray-400" id="current-mode-display">模式: 普通</span>
        </div>
        <div class="flex flex-col sm:flex-row items-center space-x-2">
            <div class="flex items-center text-xs resource-display">
                生命
                <div class="resource-bar health-bar">
                    <div id="health-fill" class="resource-fill" style="width: 100%;"></div>
                </div>
            </div>
            <div class="flex items-center text-xs resource-display">
                氧气
                <div class="resource-bar oxygen-bar">
                    <div id="oxygen-fill" class="resource-fill" style="width: 100%;"></div>
                </div>
            </div>
            <div class="flex items-center text-xs resource-display">
                能源
                <div class="resource-bar energy-bar">
                    <div id="energy-fill" class="resource-fill" style="width: 100%;"></div>
                </div>
            </div>
        </div>
        <div class="flex items-center text-sm space-x-2">
            <!-- 按钮文本将在 JS 中动态设置：返回菜单 或 放弃逃生 -->
            <button id="reset-game-button" class="action-button px-3 py-1 text-xs" style="border-color: #6366f1; background: #4f46e5;">返回菜单 (Menu)</button>
            <span>SP: <span id="skill-point-display" class="ml-1 text-lg text-green-400">5</span></span>
            <button id="skill-tree-button" class="action-button px-3 py-1 text-xs" style="border-color: #10b981; background: #064e3b;" disabled>技能树</button>
        </div>
    </div>

    <!-- Random Event Display -->
    <div id="event-display" class=""></div>

    <!-- Canvas -->
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <!-- Game Status Overlay -->
    <div id="game-status-overlay" class="game-status absolute inset-0 hidden">
        <div class="p-8 bg-gray-800/90 rounded-xl shadow-2xl border-4 border-yellow-500">
            <h1 id="status-title">星域长剑：零重力逃生</h1>
            <p id="status-message">WASD/方向键 推进器 | 鼠标点击/触摸 虚空之刃牵引 | R 虹吸能源 | P/Space 斩击</p>
            
            <h3 class="text-xl text-yellow-400 mt-6 mb-4">选择模式</h3>
            <div class="status-options">
                <button id="mode-normal" data-mode="Normal">普通模式 (Normal) - 基础体验</button>
                <button id="mode-hardcore" data-mode="Hardcore">硬核模式 (Hardcore) - 资源消耗增加</button>
            </div>
            
            <p class="text-xs text-gray-400 mt-4">当前用户ID (分享此ID): <span id="user-id-overlay">加载中...</span></p>
            <p id="high-score-display" class="text-sm mt-2 text-green-300">本地最佳时间: N/A | 全局最佳时间: N/A</p>
            
            <button id="next-step-button" class="mt-4 hidden">继续到技能树</button>
        </div>
    </div>
    
    <!-- Skill Tree Modal -->
    <div id="skill-tree-modal" class="modal hidden">
        <div class="modal-content">
            <h2 class="text-center">虚空技能树</h2>
            <p class="text-center text-sm mb-4">可用技能点: <span id="modal-skill-point-display" class="text-green-400 text-lg font-bold">0</span> SP</p>
            <p class="text-center text-xs text-gray-400 mb-4">游戏开始前您有一次免费分配初始技能点的机会。</p>

            <div id="skill-nodes-container" class="space-y-4 max-h-80 overflow-y-auto pr-2">
                <!-- Skill nodes will be injected here -->
            </div>
            
            <button id="close-skill-tree" class="mt-6">返回游戏</button>
        </div>
    </div>

    <!-- Desktop Controls Hint -->
    <div class="control-buttons desktop-controls">
        <span class="text-sm text-gray-400">WASD/方向键: 推进 | 鼠标左键: 牵引 | R: 虹吸 | P/Space: 斩击</span>
    </div>

    <!-- Mobile Controls -->
    <div id="mobile-controls">
        <div id="mobile-dpad" class="flex-row">
            <button id="thrust-up" class="mobile-button">↑</button>
            <button id="thrust-down" class="mobile-button">↓</button>
            <button id="thrust-left" class="mobile-button">←</button>
            <button id="thrust-right" class="mobile-button">→</button>
        </div>
        <div id="mobile-action-buttons">
            <button id="action-grapple" class="mobile-button">牵引</button>
            <button id="action-siphon" class="mobile-button">虹吸</button>
            <button id="action-slash" class="mobile-button">斩击</button>
        </div>
    </div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, query, limit, where, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- Firebase Setup and Constants (MANDATORY GLOBALS) ---
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
    
    let db, auth;
    let userId = 'loading';
    let isAuthReady = false;
    let globalBestTime = 'N/A';
    let userBestTime = 'N/A';
    let initialAuthComplete = false; 

    setLogLevel('Debug');

    if (firebaseConfig) {
        const app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        auth = getAuth(app);

        // 尝试使用自定义 Token 登录 (会触发 onAuthStateChanged)
        if (initialAuthToken) {
            signInWithCustomToken(auth, initialAuthToken).catch(error => {
                console.error("Custom token sign in failed:", error);
            });
        }

        onAuthStateChanged(auth, async (user) => {
            if (initialAuthComplete) return; 

            // 如果 onAuthStateChanged 触发时没有用户（例如自定义 Token 失败），尝试匿名登录
            if (!user) {
                try {
                    await signInAnonymously(auth);
                    user = auth.currentUser; // 获取新登录的匿名用户
                } catch (error) {
                    console.error("Anonymous sign in failed:", error);
                    // 如果匿名登录失败，user 保持为 null
                }
            }
            
            if (user) {
                userId = user.uid;
            } else {
                // 如果所有认证尝试都失败，设置一个清晰的未登录状态
                userId = '未登录 (无权限)'; 
            }
            
            const userIdDisplay = document.getElementById('user-id-display');
            if (userIdDisplay) {
                // UI 上显示用户 ID 或未登录提示
                userIdDisplay.textContent = userId;
            }
            document.getElementById('user-id-overlay').textContent = userId;

            isAuthReady = true;
            initialAuthComplete = true; // 标志认证流程完成
            listenForScores();
        });

    } else {
        // 无 Firebase 配置时的默认行为
        userId = '无Firebase配置';
        
        const userIdDisplay = document.getElementById('user-id-display');
        if (userIdDisplay) {
            userIdDisplay.textContent = userId;
        }
        document.getElementById('user-id-overlay').textContent = userId;
        isAuthReady = true;
        initialAuthComplete = true; 
        console.warn("Firebase config not found. Running without persistent storage.");
    }

    async function saveBestTime(time) {
        // --- FIX: 严格检查是否已登录 ---
        if (!isAuthReady || !db || !auth.currentUser) {
            console.warn("保存分数失败: 用户未认证或 Firebase 未就绪。");
            return;
        }
        
        const currentUid = auth.currentUser.uid;
        const scoreCollectionRef = collection(db, 'artifacts', appId, 'public', 'data', 'zero_g_escape_scores');
        const userDocRef = doc(scoreCollectionRef, currentUid);
        const newTimeInSeconds = (time / 1000).toFixed(2);
        
        // ADDED DEBUG LOG: Confirm the UID being used for setDoc
        console.log(`[DEBUG] Attempting setDoc for user ID: ${currentUid}`);

        try {
            const docSnap = await getDoc(userDocRef);
            let shouldUpdate = false;
            if (docSnap.exists()) {
                const data = docSnap.data();
                // We check if the new time is LESS than the old best time (lower is better)
                if (parseFloat(newTimeInSeconds) < parseFloat(data.bestTimeSeconds) || parseFloat(data.bestTimeSeconds) === 0) {
                    shouldUpdate = true;
                }
            } else {
                shouldUpdate = true;
            }

            if (shouldUpdate) {
                // The inclusion of userId: currentUid is CRITICAL for passing security rules
                await setDoc(userDocRef, {
                    userId: currentUid, 
                    bestTimeSeconds: newTimeInSeconds,
                    timestamp: Date.now(),
                }, { merge: true });
            }
        } catch (e) {
            // Log the error if the write attempt fails due to actual permission issues or network errors
            console.error("Error saving score (Permission/Firestore issue):", e);
        }
    }

    function listenForScores() {
        if (!isAuthReady || !db) return;

        const scoreCollectionRef = collection(db, 'artifacts', appId, 'public', 'data', 'zero_g_escape_scores');
        
        // 1. 监听用户个人最佳时间 (需要认证)
        if (auth.currentUser) {
            const userDocRef = doc(scoreCollectionRef, auth.currentUser.uid);
            onSnapshot(userDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    userBestTime = parseFloat(docSnap.data().bestTimeSeconds).toFixed(2) + 's';
                } else {
                    userBestTime = 'N/A (新用户)';
                }
                updateHighScoreDisplay();
            });
        } else {
            userBestTime = '未登录';
            updateHighScoreDisplay();
        }

        // 2. 监听全局最佳时间 (通常允许未认证用户读取)
        onSnapshot(scoreCollectionRef, (snapshot) => {
            let scores = [];
            snapshot.forEach(doc => {
                const data = doc.data();
                scores.push({ time: parseFloat(data.bestTimeSeconds), userId: data.userId });
            });

            if (scores.length > 0) {
                scores.sort((a, b) => a.time - b.time);
                // 检查全局最佳是否是当前用户
                globalBestTime = scores[0].time.toFixed(2) + 's' + (scores[0].userId === auth.currentUser?.uid ? ' (您)' : '');
            } else {
                globalBestTime = 'N/A';
            }
            updateHighScoreDisplay();
        });
    }

    function formatTime(ms) {
        const totalSeconds = Math.floor(ms / 1000);
        const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, '0');
        const seconds = String(totalSeconds % 60).padStart(2, '0');
        const milliseconds = String(Math.floor((ms % 1000) / 10)).padStart(2, '0');
        return `${minutes}:${seconds}.${milliseconds}`;
    }

    function updateHighScoreDisplay() {
        const display = document.getElementById('high-score-display');
        if (display) {
            display.innerHTML = `本地最佳时间 (User): <span class="text-white">${userBestTime}</span> | 全局最佳时间: <span class="text-white">${globalBestTime}</span>`;
        }
    }

    // --- Game Engine Core ---

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const GAME_WIDTH = 800;
    const GAME_HEIGHT = 600;
    canvas.width = GAME_WIDTH;
    canvas.height = GAME_HEIGHT;

    // JS Color Constants
    const COLOR_PRIMARY = '#1e3a8a';
    const COLOR_SECONDARY = '#fcd34d';
    const COLOR_DANGER = '#dc2626';
    const COLOR_TEXT = '#e0f2f1';
    const COLOR_TEAL = '#0d9488';
    const COLOR_DARK_GREY = '#374151';
    const COLOR_BG = '#152135';

    // Game Constants
    const ZERO_G_DRAG = 0.998;
    const MAX_VELOCITY = 10;
    const THRUST_FORCE = 0.05;
    
    const OXYGEN_DRAIN_RATE_NORMAL = 0.005; 
    const OXYGEN_DRAIN_RATE_HARDCORE = 0.01; 
    
    // Base Energy consumption 
    const ENERGY_DRAIN_THRUST_BASE = 0.04; 
    const ENERGY_DRAIN_TETHER_BASE = 0.07;
    const ENERGY_DRAIN_SLASH_BASE = 3; 

    const ENERGY_SIPHON_GAIN = 100;
    const HEALTH_RECOVERY_RATE = 0.01;
    const SIPHON_COOLDOWN_FRAMES = 600; // 10 seconds

    const TIME_PER_SKILL_POINT_MS = 60000; // 1 minute = 1 SP
    const EVENT_INTERVAL_MS = 60000; // 1 minute for random events

    // Game State
    let gameState = {
        running: false,
        startTime: 0,
        elapsedTime: 0,
        lastSkillPointTime: 0,
        lastEventTime: 0,
        siphonCooldown: 0,
        isGrappling: false,
        grappleTarget: { x: 0, y: 0 },
        isSlashing: false,
        slashFrameCount: 0,
        mode: null, 
        skillTreeVisible: false,
    };

    // Player Object (Kael)
    let player = {
        x: 50,
        y: GAME_HEIGHT / 2,
        radius: 10,
        velX: 0,
        velY: 0,
        health: 100,
        oxygen: 100,
        energy: 100, 
        skillPoints: 5, // Initial SP for pre-game customization
    };

    // Environment/Colliders (Walls, Hazards, Resources) - kept simple
    let walls = [
        { x: 0, y: 0, w: GAME_WIDTH, h: 10, type: 'wall' },
        { x: 0, y: GAME_HEIGHT - 10, w: GAME_WIDTH, h: 10, type: 'wall' },
        { x: 0, y: 0, w: 10, h: GAME_HEIGHT, type: 'wall' },
        { x: GAME_WIDTH - 20, y: 0, w: 20, h: 50, type: 'goal' },
        { x: 200, y: 100, w: 20, h: 300, type: 'wall' },
        { x: 400, y: 200, w: 200, h: 20, type: 'wall' },
    ];
    let hazards = [
        { x: 300, y: 0, w: 50, h: 150, type: 'radiation', damage: 0.1 },
        { x: 500, y: 400, w: 100, h: 100, type: 'heat', damage: 0.05 },
    ];
    let resources = [
        { x: 100, y: 100, radius: 15, type: 'oxygen', amount: 50 },
        { x: 600, y: 500, radius: 15, type: 'energy', amount: 50 },
        { x: 300, y: 300, radius: 10, type: 'siphon_point', isSiphoning: false, range: 50 },
    ];
    let enemies = [];
    
    function resetEnvironment() {
        resources = [
            { x: 100, y: 100, radius: 15, type: 'oxygen', amount: 50 },
            { x: 600, y: 500, radius: 15, type: 'energy', amount: 50 },
            { x: 300, y: 300, radius: 10, type: 'siphon_point', isSiphoning: false, range: 50 },
        ];
        enemies = [
            createEnemy(400, 100),
            createEnemy(500, 300),
            createEnemy(700, 400),
        ];
    }

    function createEnemy(x, y) {
        return {
            x: x, y: y, radius: 8, velX: (Math.random() - 0.5) * 0.5, velY: (Math.random() - 0.5) * 0.5,
            health: 20, maxHealth: 20, type: 'Maint-Drone', color: '#8b5cf6'
        };
    }

    // --- Skill Tree Data ---
    const SKILL_TREE = {
        'KineticEfficiency': { 
            id: 'KineticEfficiency', name: "动能效率", 
            desc: (level) => `推进器/牵引能源消耗减少 ${level * 10}%。`, 
            maxLevel: 3, 
            cost: [1, 2, 3],
            getEffect: (level) => ({ thrustDrainMult: 1 - level * 0.10, tetherDrainMult: 1 - level * 0.10 })
        },
        'VoidBladeMastery': { 
            id: 'VoidBladeMastery', name: "虚空之刃精通", 
            desc: (level) => `斩击范围增加 ${level * 10}，斩击能源消耗减少 ${level * 0.5}。`, 
            maxLevel: 3, 
            cost: [2, 3, 4],
            getEffect: (level) => ({ slashRangeBonus: level * 10, slashDrainReduction: level * 0.5 })
        },
        'ResourceRegeneration': {
            id: 'ResourceRegeneration', name: "资源再生",
            desc: (level) => `提高氧气恢复和生命恢复 ${level * 0.05}。`,
            maxLevel: 2,
            cost: [3, 5],
            getEffect: (level) => ({ passiveHealthRecoveryBonus: level * 0.05, passiveOxygenRecoveryBonus: level * 0.05 })
        }
    };
    
    let activeSkills = {
        'KineticEfficiency': 0,
        'VoidBladeMastery': 0,
        'ResourceRegeneration': 0,
    };
    
    let skillEffects = {}; // Computed effects stored here

    function calculateSkillEffects() {
        // Reset effects
        skillEffects = {
            thrustDrainMult: 1,
            tetherDrainMult: 1,
            slashRangeBonus: 0,
            slashDrainReduction: 0,
            passiveHealthRecoveryBonus: 0,
            passiveOxygenRecoveryBonus: 0,
        };

        for (const skillId in activeSkills) {
            const level = activeSkills[skillId];
            if (level > 0) {
                const skill = SKILL_TREE[skillId];
                const effects = skill.getEffect(level);
                
                // Merge effects
                for (const key in effects) {
                    if (key.endsWith('Mult')) {
                        skillEffects[key] *= effects[key]; // Multiplicative
                    } else {
                        skillEffects[key] += effects[key]; // Additive
                    }
                }
            }
        }
    }

    // --- Random Event Data ---
    const RANDOM_EVENTS = [
        { name: "舱室减压", type: 'OxygenLeak', message: "警告！氧气泄漏！(O2 消耗速度加倍，持续 15 秒)", duration: 900, effect: { oxygenDrainMult: 2.0 } }, // 15s * 60FPS = 900 frames
        { name: "能源脉冲", type: 'EnergySurge', message: "检测到能源脉冲！(立即恢复 25 能源)", duration: 0, effect: { energyGain: 25 } },
        { name: "碎片群", type: 'DebrisField', message: "附近出现碎片群！(所有移动阻力增加 10 秒)", duration: 600, effect: { dragMult: 0.99 } },
        { name: "紧急维修", type: 'EmergencyRepair', message: "系统自动修复，生命值小幅恢复。", duration: 0, effect: { healthGain: 10 } }
    ];
    let activeEvent = null;
    let eventFrameCount = 0;
    
    function triggerRandomEvent() {
        if (!gameState.running) return;

        const event = RANDOM_EVENTS[Math.floor(Math.random() * RANDOM_EVENTS.length)];
        activeEvent = event;
        eventFrameCount = 0;
        
        const display = document.getElementById('event-display');
        display.textContent = `${event.name}: ${event.message.split('(')[0]}`;
        display.classList.add('event-active');
        
        // Apply instant effects
        if (event.effect.energyGain) {
            player.energy = Math.min(100, player.energy + event.effect.energyGain);
        }
        if (event.effect.healthGain) {
            player.health = Math.min(100, player.health + event.effect.healthGain);
        }

        // Hide display after 5 seconds if duration is non-zero (or instant)
        if (event.duration > 0 || event.duration === 0) {
            setTimeout(() => {
                display.classList.remove('event-active');
            }, 5000); 
        }
    }

    function updateRandomEvent() {
        if (!activeEvent) return;

        eventFrameCount++;

        // End timed event
        if (activeEvent.duration > 0 && eventFrameCount >= activeEvent.duration) {
            activeEvent = null;
            document.getElementById('event-display').classList.remove('event-active');
        }
    }


    // --- Input Handling ---
    let keys = {};
    let touchStartPos = { x: 0, y: 0 };

    document.addEventListener('keydown', (e) => {
        keys[e.key] = true;
        if (!gameState.running || gameState.skillTreeVisible) return; 
        if (e.key === 'R' || e.key === 'r') siphonPower();
        if (e.key === ' ' || e.key === 'p' || e.key === 'P') slashAttack();
        if (e.key === 't' || e.key === 'T') toggleSkillTree();
    });
    document.addEventListener('keyup', (e) => {
        keys[e.key] = false;
    });

    canvas.addEventListener('mousedown', (e) => {
        if (!gameState.running || gameState.skillTreeVisible) return;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        gameState.isGrappling = true;
        gameState.grappleTarget.x = (e.clientX - rect.left) * scaleX;
        gameState.grappleTarget.y = (e.clientY - rect.top) * scaleY;
    });

    canvas.addEventListener('mouseup', () => {
        gameState.isGrappling = false;
    });
    
    canvas.addEventListener('touchstart', (e) => {
        if (!gameState.running || gameState.skillTreeVisible) return;
        e.preventDefault();
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        touchStartPos.x = touch.clientX;
        touchStartPos.y = touch.clientY;

        gameState.isGrappling = true;
        gameState.grappleTarget.x = (touch.clientX - rect.left) * scaleX;
        gameState.grappleTarget.y = (touch.clientY - rect.top) * scaleY;
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
        gameState.isGrappling = false;
        const touch = e.changedTouches[0];
        if (Math.abs(touch.clientX - touchStartPos.x) < 10 && Math.abs(touch.clientY - touchStartPos.y) < 10) {
            slashAttack();
        }
    });

    function setupMobileControls() {
        const buttons = [
            { id: 'thrust-up', keys: ['ArrowUp', 'w'], event: 'touchstart' },
            { id: 'thrust-down', keys: ['ArrowDown', 's'], event: 'touchstart' },
            { id: 'thrust-left', keys: ['ArrowLeft', 'a'], event: 'touchstart' },
            { id: 'thrust-right', keys: ['ArrowRight', 'd'], event: 'touchstart' },
        ];

        buttons.forEach(({ id, keys: keyList }) => {
            const btn = document.getElementById(id);
            if (btn) {
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    keyList.forEach(key => keys[key] = true);
                });
                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    keyList.forEach(key => keys[key] = false);
                });
            }
        });

        document.getElementById('action-siphon')?.addEventListener('click', siphonPower);
        document.getElementById('action-slash')?.addEventListener('click', slashAttack);
    }

    // --- Game Setup and Control ---

    function setupGameMode(mode) {
        if (gameState.running) return;
        
        gameState.mode = mode;
        const modeText = mode === 'Hardcore' ? '硬核 (消耗 X2)' : '普通';
        document.getElementById('current-mode-display').textContent = `模式: ${modeText}`;
        document.getElementById('status-message').textContent = `已选择 ${modeText} 模式。请继续到技能树进行初始技能分配。`;
    }
    
    function continueToSkillTree() {
        if (!gameState.mode) {
             document.getElementById('status-message').textContent = "请先选择一个游戏模式！";
             return;
        }
        document.getElementById('game-status-overlay').classList.add('hidden');
        toggleSkillTree(true);
    }
    
    // Function to start the game from the Skill Tree Modal (BUG FIX APPLIED HERE)
    function startGameFromModal() {
        // Remove the temporary start listener and add the in-game close listener back
        document.getElementById('close-skill-tree').removeEventListener('click', startGameFromModal);
        document.getElementById('close-skill-tree').addEventListener('click', () => toggleSkillTree(false));

        startGame();
    }

    function startGame() {
        if (gameState.running) return;

        // Reset player state (Keep the spent skill points from pre-game)
        player.x = 50;
        player.y = GAME_HEIGHT / 2;
        player.velX = 0;
        player.velY = 0;
        player.health = 100;
        player.oxygen = 100;
        player.energy = 100;
        
        resetEnvironment(); // Reset enemy and resource positions

        // Reset game state
        gameState.running = true;
        gameState.skillTreeVisible = false; // <<< BUG FIX: Ensure game logic loop starts
        gameState.startTime = Date.now();
        gameState.lastSkillPointTime = Date.now();
        gameState.lastEventTime = Date.now();
        gameState.siphonCooldown = 0;
        activeEvent = null;
        
        document.getElementById('game-status-overlay').classList.add('hidden');
        document.getElementById('skill-tree-modal').classList.add('hidden');

        document.getElementById('skill-tree-button').disabled = false;
        updateUI(); 
    }

    /**
     * Resets the game entirely to the mode selection screen (Main Menu).
     * This function is triggered by the dynamic "返回菜单/放弃逃生" button.
     */
    function resetGameToInitialState() {
        // 1. Stop Game
        gameState.running = false;
        gameState.skillTreeVisible = false;
        document.getElementById('event-display').classList.remove('event-active');

        // 2. Reset Game State and Player
        gameState.mode = null;
        player.health = 100;
        player.oxygen = 100;
        player.energy = 100;
        player.skillPoints = 5;
        
        // 3. Reset Skills to zero and recalculate effects
        for (const skillId in activeSkills) {
            activeSkills[skillId] = 0;
        }
        calculateSkillEffects();

        // 4. Show Initial Overlay (Mode Selection)
        const overlay = document.getElementById('game-status-overlay');
        document.getElementById('status-title').textContent = "星域长剑：零重力逃生";
        document.getElementById('status-message').textContent = "WASD/方向键 推进器 | 鼠标点击/触摸 虚空之刃牵引 | R 虹吸能源 | P/Space: 斩击";
        document.querySelector('.status-options').classList.remove('hidden');
        document.getElementById('next-step-button').classList.add('hidden');
        
        // 5. Reset UI elements
        document.getElementById('current-mode-display').textContent = `模式: 普通`;
        document.getElementById('time-display').textContent = '00:00.00';
        document.getElementById('skill-tree-button').disabled = true;

        updateUI();
        overlay.classList.remove('hidden');
    }

    function gameOver(win = false) {
        gameState.running = false;
        document.getElementById('skill-tree-button').disabled = true; // Disable in-game button

        const overlay = document.getElementById('game-status-overlay');
        const title = document.getElementById('status-title');
        const message = document.getElementById('status-message');
        const nextStepButton = document.getElementById('next-step-button');
        
        if (win) {
            const finalTime = gameState.elapsedTime;
            title.textContent = "逃生成功！ (Escape Successful!)";
            message.textContent = `您在 ${formatTime(finalTime)} 内抵达方舟。这是星域长剑的胜利！`;
            saveBestTime(finalTime);
        } else {
            title.textContent = "逃生失败 (Escape Failed)";
            message.textContent = player.health <= 0 ? "生命耗尽，系统关闭。" : "氧气耗尽，虚空长眠。";
        }
        
        // Return to initial state flow
        document.querySelector('.status-options').classList.remove('hidden');
        nextStepButton.classList.add('hidden');
        gameState.mode = null; // Reset mode selection

        updateHighScoreDisplay();
        overlay.classList.remove('hidden');
        updateUI(); // Update UI to show "Return to Menu"
    }

    // --- Skill Tree Logic ---
    function toggleSkillTree(fromStatusScreen = false) {
        
        if (!gameState.running && !fromStatusScreen) {
             gameState.skillTreeVisible = false;
             document.getElementById('skill-tree-modal').classList.add('hidden');
             document.getElementById('game-status-overlay').classList.remove('hidden');
             return;
        }

        gameState.skillTreeVisible = !gameState.skillTreeVisible;
        const modal = document.getElementById('skill-tree-modal');
        const closeButton = document.getElementById('close-skill-tree');

        if (gameState.skillTreeVisible) {
            modal.classList.remove('hidden');
            renderSkillTree();
            
            // Cleanup listeners
            closeButton.removeEventListener('click', () => toggleSkillTree(false)); 
            closeButton.removeEventListener('click', startGameFromModal);

            // Change button text based on game state
            if (!gameState.running) {
                closeButton.textContent = '确认技能, 开始逃生';
                closeButton.addEventListener('click', startGameFromModal);
            } else {
                closeButton.textContent = '返回游戏';
                closeButton.addEventListener('click', () => toggleSkillTree(false));
            }

        } else {
            modal.classList.add('hidden');
        }
    }

    function upgradeSkill(skillId) {
        const skill = SKILL_TREE[skillId];
        const currentLevel = activeSkills[skillId];
        
        if (currentLevel >= skill.maxLevel) return;
        
        const cost = skill.cost[currentLevel];
        if (player.skillPoints >= cost) {
            player.skillPoints -= cost;
            activeSkills[skillId]++;
            calculateSkillEffects(); // Recalculate effects immediately
            renderSkillTree();
            updateUI(); // Update SP display
        }
    }

    function renderSkillTree() {
        const container = document.getElementById('skill-nodes-container');
        const spDisplay = document.getElementById('modal-skill-point-display');
        spDisplay.textContent = player.skillPoints;
        container.innerHTML = '';

        for (const skillId in SKILL_TREE) {
            const skill = SKILL_TREE[skillId];
            const currentLevel = activeSkills[skillId];
            const nextLevel = currentLevel + 1;
            const maxLevel = skill.maxLevel;
            const cost = skill.cost[currentLevel] || null;
            
            const canUpgrade = player.skillPoints >= cost && currentLevel < maxLevel;
            const buttonText = currentLevel < maxLevel ? `升级 (消耗 ${cost} SP)` : '已达最高级';

            const element = document.createElement('div');
            element.className = 'skill-node';
            element.innerHTML = `
                <h3 class="flex justify-between items-center">${skill.name}</h3>
                <p>${skill.desc(currentLevel)}</p>
                <div class="level-info">
                    等级: ${currentLevel} / ${maxLevel} 
                    <span class="ml-4 text-xs text-gray-500">${currentLevel < maxLevel ? `下一级: ${skill.desc(nextLevel)}` : ''}</span>
                </div>
                <button class="upgrade-button mt-2" data-skill-id="${skillId}" ${!canUpgrade ? 'disabled' : ''}>
                    ${buttonText}
                </button>
            `;
            
            container.appendChild(element);
        }

        // Attach event listeners to new buttons (using delegation or cloning for safety)
        container.querySelectorAll('.upgrade-button').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            
            newButton.addEventListener('click', (e) => {
                upgradeSkill(e.target.dataset.skillId);
            });
        });
    }

    // --- Core Mechanisms (The Void-Blade) ---

    function siphonPower() {
        if (!gameState.running || gameState.siphonCooldown > 0) return;
        
        const siphonPoint = resources.find(r => r.type === 'siphon_point');
        if (siphonPoint) {
            const dx = siphonPoint.x - player.x;
            const dy = siphonPoint.y - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < siphonPoint.range + player.radius) {
                player.energy = Math.min(100, player.energy + ENERGY_SIPHON_GAIN);
                gameState.siphonCooldown = SIPHON_COOLDOWN_FRAMES;
            } else {
                console.log("Too far from a Siphon Point.");
            }
        }
    }

    function slashAttack() {
        // Apply skill reduction to consumption
        const slashCost = Math.max(0.5, ENERGY_DRAIN_SLASH_BASE - skillEffects.slashDrainReduction);

        if (!gameState.running || player.energy < slashCost || gameState.isSlashing) return;
        
        player.energy = Math.max(0, player.energy - slashCost);
        gameState.isSlashing = true;
        gameState.slashFrameCount = 0;
    }

    function updateSlash() {
        if (!gameState.isSlashing) return;

        gameState.slashFrameCount++;
        const slashDuration = 10; // frames

        if (gameState.slashFrameCount > slashDuration) {
            gameState.isSlashing = false;
            return;
        }

        let dirX = player.velX || 1;
        let dirY = player.velY || 0;
        const magnitude = Math.sqrt(dirX * dirX + dirY * dirY) || 1;
        dirX /= magnitude;
        dirY /= magnitude;

        // Apply skill bonus to slash range
        const slashRange = 40 + skillEffects.slashRangeBonus;
        const slashRadius = 20;

        // Check for enemy hit
        enemies.forEach(enemy => {
            const dx = enemy.x - (player.x + dirX * slashRange / 2);
            const dy = enemy.y - (player.y + dirY * slashRange / 2);
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < enemy.radius + slashRadius) {
                enemy.health -= 10;
                // Grant skill point on kill
                if (enemy.health <= 0) {
                    player.skillPoints += 1;
                }
                
                const momentumForce = 5;
                enemy.velX += dirX * momentumForce;
                enemy.velY += dirY * momentumForce;

                player.velX -= dirX * momentumForce * 0.2;
                player.velY -= dirY * momentumForce * 0.2;
            }
        });
    }

    // --- Physics and Update Logic ---
    
    function updateGameTime() {
        gameState.elapsedTime = Date.now() - gameState.startTime;
        
        // 1. Skill Point Earning (Time-based)
        if (gameState.elapsedTime - gameState.lastSkillPointTime >= TIME_PER_SKILL_POINT_MS) {
            player.skillPoints += 1;
            gameState.lastSkillPointTime += TIME_PER_SKILL_POINT_MS;
        }
        
        // 2. Random Event Trigger
        if (gameState.elapsedTime - gameState.lastEventTime >= EVENT_INTERVAL_MS) {
            triggerRandomEvent();
            gameState.lastEventTime = Date.now(); 
        }
    }

    function updatePlayer() {
        // Apply skill reductions to energy consumption
        const thrustCost = ENERGY_DRAIN_THRUST_BASE * skillEffects.thrustDrainMult;
        const tetherCost = ENERGY_DRAIN_TETHER_BASE * skillEffects.tetherDrainMult;

        // 1. Thrust Input
        const inputX = (keys['ArrowRight'] || keys['d'] ? 1 : 0) - (keys['ArrowLeft'] || keys['a'] ? 1 : 0);
        const inputY = (keys['ArrowDown'] || keys['s'] ? 1 : 0) - (keys['ArrowUp'] || keys['w'] ? 1 : 0);
        
        if ((inputX !== 0 || inputY !== 0) && player.energy > 0) {
            player.velX += inputX * THRUST_FORCE;
            player.velY += inputY * THRUST_FORCE;
            player.energy = Math.max(0, player.energy - thrustCost);
        }

        // 2. Grapple/Tether
        if (gameState.isGrappling && player.energy > 0) {
            const dx = gameState.grappleTarget.x - player.x;
            const dy = gameState.grappleTarget.y - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > player.radius) {
                const angle = Math.atan2(dy, dx);
                const tetherForce = 0.5;
                player.velX += Math.cos(angle) * tetherForce;
                player.velY += Math.sin(angle) * tetherForce;
                player.energy = Math.max(0, player.energy - tetherCost);
            } else {
                gameState.isGrappling = false;
            }
        } else {
            gameState.isGrappling = false;
        }

        // 3. Apply Zero-G Drag (Modified by active event)
        let drag = ZERO_G_DRAG;
        if (activeEvent && activeEvent.effect.dragMult) {
            drag = activeEvent.effect.dragMult;
        }
        player.velX *= drag;
        player.velY *= drag;

        // 4. Limit Velocity
        const speed = Math.sqrt(player.velX * player.velX + player.velY * player.velY);
        if (speed > MAX_VELOCITY) {
            const ratio = MAX_VELOCITY / speed;
            player.velX *= ratio;
            player.velY *= ratio;
        }

        // 5. Apply Position Update
        player.x += player.velX;
        player.y += player.velY;

        // 6. Resource Management (Oxygen Drain)
        let oxygenDrain = gameState.mode === 'Hardcore' ? OXYGEN_DRAIN_RATE_HARDCORE : OXYGEN_DRAIN_RATE_NORMAL;
        if (activeEvent && activeEvent.effect.oxygenDrainMult) {
             oxygenDrain *= activeEvent.effect.oxygenDrainMult;
        }
        player.oxygen = Math.max(0, player.oxygen - oxygenDrain + skillEffects.passiveOxygenRecoveryBonus);
        
        // Health Recovery
        player.health = Math.min(100, player.health + HEALTH_RECOVERY_RATE + skillEffects.passiveHealthRecoveryBonus);
    }

    function checkCollisions() {
        walls.forEach(wall => {
            const closestX = Math.max(wall.x, Math.min(player.x, wall.x + wall.w));
            const closestY = Math.max(wall.y, Math.min(player.y, wall.y + wall.h));
            const dx = player.x - closestX;
            const dy = player.y - closestY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < player.radius) {
                if (wall.type === 'goal') {
                    gameOver(true);
                    return;
                }
                const overlap = player.radius - distance;
                const pushX = dx / distance * overlap;
                const pushY = dy / distance * overlap;
                player.x += pushX;
                player.y += pushY;
                const bounceFactor = 0.8;
                if (Math.abs(closestX - player.x) > Math.abs(closestY - player.y)) {
                    player.velX *= -bounceFactor;
                } else {
                    player.velY *= -bounceFactor;
                }
                player.health = Math.max(0, player.health - Math.min(10, Math.sqrt(player.velX * player.velX + player.velY * player.velY) * 2));
            }
        });

        hazards.forEach(hazard => {
            const closestX = Math.max(hazard.x, Math.min(player.x, hazard.x + hazard.w));
            const closestY = Math.max(hazard.y, Math.min(player.y, hazard.y + hazard.h));
            const dx = player.x - closestX;
            const dy = player.y - closestY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < player.radius) {
                player.health = Math.max(0, player.health - hazard.damage);
            }
        });

        resources = resources.filter(resource => {
            if (resource.type === 'siphon_point') return true; 

            const dx = resource.x - player.x;
            const dy = resource.y - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < player.radius + resource.radius) {
                if (resource.type === 'oxygen') {
                    player.oxygen = Math.min(100, player.oxygen + resource.amount);
                } else if (resource.type === 'energy') { 
                    player.energy = Math.min(100, player.energy + resource.amount);
                }
                return false;
            }
            return true;
        });

        enemies.forEach(enemy => {
            const dx = enemy.x - player.x;
            const dy = enemy.y - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < player.radius + enemy.radius) {
                player.health = Math.max(0, player.health - 5);
                const overlap = player.radius + enemy.radius - dist;
                const angle = Math.atan2(dy, dx);
                const totalMass = player.radius + enemy.radius;
                const playerMassRatio = enemy.radius / totalMass;
                const enemyMassRatio = player.radius / totalMass;

                player.x -= Math.cos(angle) * overlap * playerMassRatio;
                player.y -= Math.sin(angle) * overlap * playerMassRatio;
                enemy.x += Math.cos(angle) * overlap * enemyMassRatio;
                enemy.y += Math.sin(angle) * overlap * enemyMassRatio;

                player.velX -= Math.cos(angle) * 1.5;
                player.velY -= Math.sin(angle) * 1.5;
                enemy.velX += Math.cos(angle) * 1.5;
                enemy.velY += Math.sin(angle) * 1.5;
            }
        });
    }

    function updateEnemies() {
        enemies = enemies.filter(enemy => enemy.health > 0);

        enemies.forEach(enemy => {
            enemy.velX *= ZERO_G_DRAG;
            enemy.velY *= ZERO_G_DRAG;

            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > 100) {
                 const angle = Math.atan2(dy, dx);
                 enemy.velX += Math.cos(angle) * 0.01;
                 enemy.velY += Math.sin(angle) * 0.01;
            }

            enemy.x += enemy.velX;
            enemy.y += enemy.velY;

            if (enemy.x - enemy.radius < 0 || enemy.x + enemy.radius > GAME_WIDTH) {
                enemy.velX *= -1;
                enemy.x = Math.min(GAME_WIDTH - enemy.radius, Math.max(enemy.radius, enemy.x));
            }
            if (enemy.y - enemy.radius < 0 || enemy.y + enemy.radius > GAME_HEIGHT) {
                enemy.velY *= -1;
                enemy.y = Math.min(GAME_HEIGHT - enemy.radius, Math.max(enemy.radius, enemy.y));
            }
        });
    }


    // --- Drawing Functions ---

    function drawPlayer() {
        // Player Body
        ctx.fillStyle = player.health > 25 ? COLOR_TEXT : COLOR_DANGER;
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
        ctx.fill();

        // Direction indicator
        const angle = Math.atan2(player.velY, player.velX) || -Math.PI / 2;
        ctx.fillStyle = COLOR_SECONDARY;
        ctx.beginPath();
        ctx.arc(player.x + Math.cos(angle) * player.radius, player.y + Math.sin(angle) * player.radius, 3, 0, Math.PI * 2);
        ctx.fill();
    }

    function drawGrapple() {
        if (gameState.isGrappling) {
            ctx.strokeStyle = COLOR_SECONDARY; 
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(player.x, player.y);
            ctx.lineTo(gameState.grappleTarget.x, gameState.grappleTarget.y);
            ctx.stroke();

            ctx.fillStyle = COLOR_SECONDARY;
            ctx.beginPath();
            ctx.arc(gameState.grappleTarget.x, gameState.grappleTarget.y, 4, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    function drawSlash() {
        if (!gameState.isSlashing) return;

        const slashPower = 1 - (gameState.slashFrameCount / 10);
        ctx.strokeStyle = `rgba(255, 255, 255, ${slashPower})`;
        ctx.lineWidth = 3;

        let dirX = player.velX || 1;
        let dirY = player.velY || 0;
        const magnitude = Math.sqrt(dirX * dirX + dirY * dirY) || 1;
        dirX /= magnitude;
        dirY /= magnitude;

        // Use skill bonus range
        const slashLength = 40 + skillEffects.slashRangeBonus;
        const startX = player.x + dirX * player.radius * 0.5;
        const startY = player.y + dirY * player.radius * 0.5;
        const endX = startX + dirX * slashLength;
        const endY = startY + dirY * slashLength;

        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
    }

    function drawEnvironment() {
        walls.forEach(wall => {
            if (wall.type === 'goal') {
                ctx.fillStyle = '#10b981';
            } else {
                ctx.fillStyle = COLOR_DARK_GREY;
            }
            ctx.fillRect(wall.x, wall.y, wall.w, wall.h);
        });

        hazards.forEach(hazard => {
            if (hazard.type === 'radiation') {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
            } else if (hazard.type === 'heat') {
                ctx.fillStyle = 'rgba(255, 165, 0, 0.1)';
            }
            ctx.fillRect(hazard.x, hazard.y, hazard.w, hazard.h);
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
            ctx.strokeRect(hazard.x, hazard.y, hazard.w, hazard.h);
        });

        resources.forEach(resource => {
            if (resource.type === 'oxygen') {
                ctx.fillStyle = COLOR_TEAL;
            } else if (resource.type === 'energy') {
                ctx.fillStyle = COLOR_SECONDARY;
            } else if (resource.type === 'siphon_point') {
                ctx.fillStyle = gameState.siphonCooldown > 0 ? '#4b5563' : COLOR_PRIMARY;
            }

            ctx.beginPath();
            ctx.arc(resource.x, resource.y, resource.radius, 0, Math.PI * 2);
            ctx.fill();

            if (resource.type === 'siphon_point' && gameState.siphonCooldown > 0) {
                const startAngle = -Math.PI / 2;
                const endAngle = startAngle + (Math.PI * 2) * (gameState.siphonCooldown / SIPHON_COOLDOWN_FRAMES);
                ctx.strokeStyle = COLOR_SECONDARY;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(resource.x, resource.y, resource.radius + 5, startAngle, endAngle, false);
                ctx.stroke();
            }
        });

        enemies.forEach(enemy => {
            ctx.fillStyle = enemy.color;
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
            ctx.fill();

            const barWidth = 20;
            const barHeight = 3;
            ctx.fillStyle = '#475569';
            ctx.fillRect(enemy.x - barWidth / 2, enemy.y - enemy.radius - barHeight - 2, barWidth, barHeight);
            ctx.fillStyle = '#dc2626';
            ctx.fillRect(enemy.x - barWidth / 2, enemy.y - enemy.radius - barHeight - 2, barWidth * (enemy.health / enemy.maxHealth), barHeight);
        });
    }

    function updateUI() {
        document.getElementById('health-fill').style.width = `${player.health.toFixed(0)}%`;
        document.getElementById('oxygen-fill').style.width = `${player.oxygen.toFixed(0)}%`;
        document.getElementById('energy-fill').style.width = `${player.energy.toFixed(0)}%`; 
        document.getElementById('skill-point-display').textContent = player.skillPoints;

        if (gameState.running) {
            document.getElementById('time-display').textContent = formatTime(gameState.elapsedTime);
        }

        // --- NEW: Dynamic "Return to Menu" button text and style ---
        const resetButton = document.getElementById('reset-game-button');
        if (gameState.running) {
            resetButton.textContent = '放弃逃生 (Abandon)';
            resetButton.style.borderColor = COLOR_DANGER;
            resetButton.style.background = '#991b1b'; // Red color
        } else {
            resetButton.textContent = '返回菜单 (Menu)';
            resetButton.style.borderColor = '#6366f1';
            resetButton.style.background = '#4f46e5'; // Blue color
        }
    }

    // --- Main Game Loop ---

    function animate(timestamp) {
        requestAnimationFrame(animate);

        if (!gameState.running) {
            if (isAuthReady) updateHighScoreDisplay();
            return;
        }

        // Only process game logic if the skill tree is not visible
        if (!gameState.skillTreeVisible) {
            // 1. Update Cooldowns and UI
            gameState.siphonCooldown = Math.max(0, gameState.siphonCooldown - 1);
            updateGameTime();
            updateUI();
            
            // 2. Physics & Logic Updates
            updatePlayer();
            updateEnemies();
            checkCollisions();
            updateSlash();
            updateRandomEvent();

            // 3. Game Over Checks
            if (player.health <= 0 || player.oxygen <= 0) {
                gameOver(false);
            }
        }


        // 4. Drawing
        ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        
        ctx.fillStyle = COLOR_BG;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        drawEnvironment();
        drawGrapple();
        drawSlash();
        drawPlayer();
    }
    
    // --- Initial Setup and Event Listeners ---
    
    document.getElementById('skill-tree-button').addEventListener('click', () => toggleSkillTree(false));
    // The main button now triggers the reset to menu state
    document.getElementById('reset-game-button').addEventListener('click', resetGameToInitialState);


    // Mode Selection Listeners
    document.getElementById('mode-normal').addEventListener('click', (e) => {
        setupGameMode(e.target.dataset.mode);
        // Hide mode selection and show next step button
        document.querySelector('.status-options').classList.add('hidden');
        document.getElementById('next-step-button').textContent = `选择 ${e.target.dataset.mode} 模式, 继续到技能树`;
        document.getElementById('next-step-button').classList.remove('hidden');
    });

    document.getElementById('mode-hardcore').addEventListener('click', (e) => {
        setupGameMode(e.target.dataset.mode);
        // Hide mode selection and show next step button
        document.querySelector('.status-options').classList.add('hidden');
        document.getElementById('next-step-button').textContent = `选择 ${e.target.dataset.mode} 模式, 继续到技能树`;
        document.getElementById('next-step-button').classList.remove('hidden');
    });

    // New listener for the "Continue" button
    document.getElementById('next-step-button').addEventListener('click', continueToSkillTree);

    function resizeCanvas() {
        const container = canvas.parentElement;
        const ratio = GAME_WIDTH / GAME_HEIGHT;
        let newWidth = container.clientWidth;
        let newHeight = newWidth / ratio;

        if (newHeight > (window.innerHeight - 150)) {
            newHeight = window.innerHeight - 150;
            newWidth = newHeight * ratio;
        }

        canvas.style.width = `${newWidth}px`;
        canvas.style.height = `${newHeight}px`;
    }

    window.addEventListener('resize', resizeCanvas);
    window.onload = () => {
        setupMobileControls();
        calculateSkillEffects(); // Initial calculation
        player.skillPoints = 5; 
        updateUI();
        resizeCanvas();
        animate(0);
    };

    // Initial check to show the start screen
    document.getElementById('game-status-overlay').classList.remove('hidden');

</script>
</body>
</html>
